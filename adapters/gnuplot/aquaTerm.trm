/* -*- objc -*-
 * $Id: aquaTerm.trm,v 1.16 2003/08/05 14:29:48 persquare Exp $
 *
 */

/* GNUPLOT - aquaTerm.trm */


/*
 * This file is included by ../term.c via ../term.h.
 *
 * This terminal driver supports:
 *     Aqua (Mac OS X/Cocoa)
 *
 * AUTHORS
 *  Per Persson from openstep.trm by Robert Lutwak
 * 
 * Homepage: http://aquaterm.sourceforge.net
 * send your comments or suggestions to (persquare@users.sourceforge.net).
 *
 * This terminal attempts to connect, via the MacOS X Distributed
 * Objects system, to the "aquatermServer."  If there is no such
 * service registered with the OS, the terminal attempts to fire
 * up AquaTerm.app.  If the user has not set the environment variable
 * GNUTERMAPP, the terminal searches for AquaTerm.app in standard 
 * locations like /Applications, ~/Applications, etc.
 * In order to use this filter, you MUST have AquaTerm.app or some other
 * application capable of handling the AQTProtocol installed
 * on your system.
 *
 * Once connected to the server, all gnuplot primitives are sent, 
 * via the D.O. system, to AquaTerm.app, which produces renders graphs, 
 * manages the windows, takes care of printing etc.
 * 
 *
 * Defaults are
 * n=0
 *
 * to choose window n
 * 'set term aqua <n>"
 *
 */

#include "driver.h"

#ifdef TERM_REGISTER
register_term(aqua)
#endif

#ifdef TERM_PROTO

/* Required entries */
TERM_PUBLIC void AQUA_options __PROTO((void));
TERM_PUBLIC void AQUA_init __PROTO((void));
TERM_PUBLIC void AQUA_reset __PROTO((void));
TERM_PUBLIC void AQUA_text __PROTO((void));
TERM_PUBLIC void AQUA_graphics __PROTO((void));
TERM_PUBLIC void AQUA_move __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void AQUA_vector __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void AQUA_linetype __PROTO((int linetype));
TERM_PUBLIC void AQUA_put_text __PROTO((unsigned int x, unsigned int y,const char *str));
/* Optional entries */
TERM_PUBLIC int AQUA_text_angle __PROTO((int));
TERM_PUBLIC int AQUA_justify_text __PROTO((enum JUSTIFY));
TERM_PUBLIC int AQUA_set_font __PROTO((const char *font));  /* "font,size" */
TERM_PUBLIC void AQUA_set_pointsize __PROTO((double size)); /* notification of set pointsize */
TERM_PUBLIC void AQUA_point __PROTO((unsigned int, unsigned int, int));
TERM_PUBLIC int flags; /* various flags */
TERM_PUBLIC void AQUA_suspend __PROTO((void)); /* after one plot of multiplot */
TERM_PUBLIC void AQUA_resume __PROTO((void));  /* before subsequent plot of multiplot */
TERM_PUBLIC void AQUA_boxfill __PROTO((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height)); /* clear part of multiplot */
TERM_PUBLIC void AQUA_linewidth __PROTO((double linewidth));
TERM_PUBLIC void AQUA_pointsize __PROTO((double pointsize));
#ifdef PM3D
  TERM_PUBLIC int AQUA_make_palette __PROTO((t_sm_palette *palette));
  TERM_PUBLIC void AQUA_set_color __PROTO((double gray));
  TERM_PUBLIC void AQUA_filled_polygon __PROTO((int points, gpiPoint *corners));
#endif /* PM3D */
/* End of entries */

#define AQUA_XMAX (11.69*72)  /* = 842, paper width times screen resolution */
#define AQUA_YMAX (8.26*72)   /* = 595, paper height times screen resolution */
#define AQUA_VTIC 8     
#define AQUA_HTIC 8
#define AQUA_VCHAR 16     /* default font is Times at 16 points */
#define AQUA_HCHAR (AQUA_VCHAR*6/10)

#define PM3D_COLORS 128
#define CYCLIC_COLORS 4

#define GOT_AQUA_PROTO
#endif /* TERM_PROTO */

#ifndef TERM_PROTO_ONLY

#ifdef TERM_BODY
#import <Foundation/Foundation.h>
#import "AQTAdapter.h"
#import "AQTGraphic.h"
/*
#import <Foundation/NSConnection.h>
#import <Foundation/NSDistantObject.h>
#import <Foundation/NSDictionary.h>
#import <Foundation/NSPortCoder.h>
#import <Foundation/NSException.h>
#import <AppKit/NSColor.h>
#import <AppKit/NSWorkspace.h>
#import <AppKit/NSBezierPath.h>
#import <stdarg.h>
*/


/* Debugging extras */
static inline void NOOP_(id x, ...) {;}

#ifdef LOGGING
#define LOG  NSLog
#else
#define LOG  NOOP_
#endif	/* LOGGING */

#define BUFMAX 50

static NSAutoreleasePool *arpool;   // our autorelease pool 
static id adapter;    // local object manages the D.O. connection
static int currentWindow = 0;		// the only option to set (could be set _before_ instatiation of gnuTermAccess)
static char AQUA_title[MAX_LINE_LEN + 1];
static t_sm_palette *aqua_palette = nil;
static AQTColor cm[256];

//
// ----------------------------------------------------------------
// Gnuplot driver implementation
// ----------------------------------------------------------------
//

enum AQUA_id {
  AQUA_DEFAULT,
  AQUA_TITLE,
  AQUA_OTHER
};


static struct gen_table AQUA_opts[] =
{
  { "d$efault", AQUA_DEFAULT },
  { "ti$tle", AQUA_TITLE },
  { NULL, AQUA_OTHER }
};

//
// AQUA_options is called 0 or more times before a call to AQUA_init occurs.
// It is important that the option <n> is passed correctly to AquaTerm
//
TERM_PUBLIC void
AQUA_options()
{
  struct value a;
  *AQUA_title = 0;
    
  LOG(@"AQUA_options");
  while (!END_OF_COMMAND) 
  {
    switch(lookup_table(&AQUA_opts[0],c_token)) 
    {
     case AQUA_DEFAULT:
      currentWindow = 0;
      c_token++;
      break;
     case AQUA_TITLE:
      c_token++;
      if (!isstring(c_token)) {
          fprintf(stderr, "usage:  set term aqua title \"newtitle\"\n");
      }
      quote_str(AQUA_title, c_token, MAX_LINE_LEN + 1);
            c_token++;

      break;
     case AQUA_OTHER:
      currentWindow = (int) real(const_express(&a));
      break;  
    default:      
      break;
    }
  }
}

TERM_PUBLIC void
AQUA_init()
{
  float fontSize, fontWHRatio;
  float vTicSize, pixelWHRatio;
  LOG(@"Aqua Init");
  if (arpool == NULL)   /* Make sure we don't leak mem by allocating every time */
  {
    arpool = [[NSAutoreleasePool alloc] init]; 
    adapter = [[AQTAdapter alloc] init]; 
  }
  else 
  {
    if (!adapter)	/* server could be invalid (=nil) for several reasons */
    {
      printf("Error -- no adapter!\n");
      exit(1);
	//adapter = [[AQTAdapter alloc] init]; 
    }
  }
  term->xmax =842; //[[[gnuTermAccess termInfo] objectForKey:@"AQTXMax"] unsignedIntValue]; 
  term->ymax =595; //[[[gnuTermAccess termInfo] objectForKey:@"AQTYMax"] unsignedIntValue]; 
  fontSize = 16; //[[[gnuTermAccess termInfo] objectForKey:@"AQTFontSize"] floatValue];
  fontWHRatio = .6; //[[[gnuTermAccess termInfo] objectForKey:@"AQTFontWHRatio"] floatValue];
  pixelWHRatio = 1.0; //[[[gnuTermAccess termInfo] objectForKey:@"AQTPixelWHRatio"] floatValue];
  vTicSize = AQUA_VTIC;
  term->v_char = (unsigned int) fontSize;
  term->h_char = (unsigned int) (fontWHRatio * fontSize);
  term->v_tic = (unsigned int) vTicSize;
  term->h_tic = (unsigned int) (vTicSize * pixelWHRatio);
  //
  // Set up the basic indexed colormap for gnuplot
  //
  cm[0].red = 1.0;
  cm[1].green = 1.0;
  cm[2].blue = 1.0;
  cm[3].red = 1.0;  cm[3].blue = 1.0;
//  [gnuTermAccess setColor:[NSColor cyanColor] forIndex:4];
//  [gnuTermAccess setColor:[NSColor colorWithCalibratedRed:0.627 green:0.322 blue:0.176 alpha:1.0] forIndex:5];   // Sienna
//  [gnuTermAccess setColor:[NSColor colorWithCalibratedRed:1.0 green: 0.647 blue:0.0 alpha:1.0] forIndex:6];      // Orange
//  [gnuTermAccess setColor:[NSColor colorWithCalibratedRed:1.0 green:0.498 blue:0.314 alpha:1.0] forIndex:7];     // Coral
}

TERM_PUBLIC void
AQUA_reset()
{
}

TERM_PUBLIC void
AQUA_text()
{
    //[gnuTermAccess flushBuffers];
    [adapter closePlot];
}

TERM_PUBLIC void
AQUA_graphics()
{
  NSString *title;
    if(*AQUA_title)
    {
        title = [NSString stringWithCString:AQUA_title];
        *AQUA_title = 0;
    }
    [adapter openPlotIndex:currentWindow size:NSMakeSize(term->xmax, term->ymax) title:nil];
}

TERM_PUBLIC void
AQUA_move(unsigned int x, unsigned int y)
{
    [adapter addLineAtPoint:NSMakePoint(x, y)];
}

TERM_PUBLIC void
AQUA_vector(unsigned int x, unsigned int y)
{
  [adapter appendLineToPoint:NSMakePoint(x, y)];
}

TERM_PUBLIC void
AQUA_linetype(int linetype)
{
  LOG(@"AQUA_linetype(%d)", linetype);
  [adapter setColor:cm[linetype%CYCLIC_COLORS]];
}

TERM_PUBLIC void
AQUA_put_text(unsigned int x, unsigned int y, const char *str)
{
  if (!strlen(str))
    return;
  [adapter  addLabel:[NSString stringWithCString: str] position:NSMakePoint(x,y) angle:0.0 justification:0];
  //[gnuTermAccess putText:str at:NSMakePoint(x,y)];
}

TERM_PUBLIC int 
AQUA_justify_text (enum JUSTIFY mode)
{
  // [gnuTermAccess  setJustification:mode];
  return (TRUE);
}

TERM_PUBLIC int
AQUA_text_angle (int angle)
{
  //[gnuTermAccess setTextAngle: angle];
  return (TRUE);
}

TERM_PUBLIC int 
AQUA_set_font(const char *font) /* "font,size" */
{
/*
  float fontWHRatio, fontSize;
  [gnuTermAccess setTextfont:font];
  // FIXME: Does gnuplot process these values?
  fontSize = [[[gnuTermAccess termInfo] objectForKey:@"AQTFontSize"] floatValue];
  fontWHRatio = [[[gnuTermAccess termInfo] objectForKey:@"AQTFontWHRatio"] floatValue];
  term->v_char = (unsigned int) fontSize;
  term->h_char = (unsigned int) (fontWHRatio * fontSize);
*/
  return (TRUE);
}

TERM_PUBLIC void 
AQUA_set_pointsize(double size) /* notification of set pointsize */
{
    LOG(@"AQUA_set_pointsize(%f)", size);
}

TERM_PUBLIC void 
AQUA_point(unsigned int x, unsigned int y, int number)
{
  // Avoid changing lw unless necessary
/*
  if ([gnuTermAccess linewidth] != 1.0)
  {
    double tmplw = [gnuTermAccess linewidth];
    [gnuTermAccess setLinewidth:1.0];
    [gnuTermAccess moveToPoint:NSMakePoint(x-.5, y)];
    [gnuTermAccess lineToPoint:NSMakePoint(x+.5, y)];
    [gnuTermAccess setLinewidth: tmplw];
  }
  else
  {
    [gnuTermAccess moveToPoint:NSMakePoint(x-.5, y)];
    [gnuTermAccess lineToPoint:NSMakePoint(x+.5, y)];
  }
*/
//  do_point(x, y, number);
}

TERM_PUBLIC void 
AQUA_suspend(void)  /* after one plot of multiplot */
{
  //[gnuTermAccess flushBuffers];
  [adapter render];
}
 
TERM_PUBLIC void 
AQUA_resume(void) /* before subsequent plot of multiplot */
{
}

TERM_PUBLIC void 
AQUA_boxfill(int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height) /* clear part of multiplot */
{
  //[gnuTermAccess fillRect:NSMakeRect(x1,y1,width,height) style:style];
}
  
TERM_PUBLIC void 
AQUA_linewidth(double linewidth)
{
  [adapter setLinewidth:linewidth];
}

TERM_PUBLIC void 
AQUA_pointsize(double pointsize)
{
  LOG(@"AQUA_pointsize(%f)", pointsize);
  term_pointsize = pointsize;
}

#ifdef PM3D
  TERM_PUBLIC int 
  AQUA_make_palette(t_sm_palette *palette)
  {
    if (palette == NULL)
    {
        return 128;
    }
    else
    {
        aqua_palette = palette;
    }
  }

  TERM_PUBLIC void 
  AQUA_set_color(double gray)
  {
    // [adapter setColorRed:gray green:gray blue:gray];
  }

  TERM_PUBLIC void 
  AQUA_filled_polygon(int points, gpiPoint *corners)
  {
    //[gnuTermAccess setPolygonUsing:points corners:corners];
  }
#endif /* PM3D */

#endif /* TERM_BODY */

#ifdef TERM_TABLE

TERM_TABLE_START(aqua_driver)
  "aqua",
  "Interface to graphics terminal server for Mac OS X",
  AQUA_XMAX, AQUA_YMAX, AQUA_VCHAR, AQUA_HCHAR, AQUA_VTIC, AQUA_HTIC, 
  AQUA_options, AQUA_init, AQUA_reset,
  AQUA_text, null_scale, AQUA_graphics, AQUA_move, AQUA_vector,
  AQUA_linetype, AQUA_put_text, 
  /* optionals */
  AQUA_text_angle,
  AQUA_justify_text, AQUA_point, do_arrow, AQUA_set_font,
  AQUA_pointsize, TERM_CAN_MULTIPLOT,
  AQUA_suspend, AQUA_resume,
  AQUA_boxfill, AQUA_linewidth
#ifdef USE_MOUSE
  , 0, 0, 0, 0, 0
#endif /* USE_MOUSE */
#ifdef PM3D
  /*
  , AQUA_make_palette,
  0 // AQUA_previous_palette ,
  AQUA_set_color,
  AQUA_filled_polygon
  */
  ,0,0,0,0
#endif /* PM3D */
TERM_TABLE_END(aqua_driver)

#undef LAST_TERM
#define LAST_TERM aqua_driver

#endif /* TERM_TABLE */
#endif /* TERM_PROTO_ONLY */



#ifdef TERM_HELP
START_HELP(aqua)
"1 aqua",
"?commands set terminal aqua",
"?set terminal aqua",
"?set term aqua",
"?terminal aqua",
"?term aqua",
"?aqua",
"?Aqua",
" Syntax:",
"   set terminal aqua {<n>} {title \"windowtitle\"}",
"",
" where <n> is the number of the window to display the plot in.",
" Default window number is 0, ",
" default windowtitle is \"Figure <n>\"."
END_HELP(aqua)
#endif /* TERM_HELP */


