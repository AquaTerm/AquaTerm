/* -*- objc -*-
 * $Id: aquaTerm.trm,v 1.19 2003/08/19 21:03:53 persquare Exp $
 *
 */

/* GNUPLOT - aquaTerm.trm */


/*
 * This file is included by ../term.c via ../term.h.
 *
 * This terminal driver supports:
 *     Aqua (Mac OS X/Cocoa)
 *
 * AUTHORS
 *  Per Persson from openstep.trm by Robert Lutwak
 * 
 * Homepage: http://aquaterm.sourceforge.net
 * send your comments or suggestions to (persquare@users.sourceforge.net).
 *
 * This terminal attempts to connect, via the MacOS X Distributed
 * Objects system, to the "aquatermServer."  If there is no such
 * service registered with the OS, the terminal attempts to fire
 * up AquaTerm.app.  If the user has not set the environment variable
 * GNUTERMAPP, the terminal searches for AquaTerm.app in standard 
 * locations like /Applications, ~/Applications, etc.
 * In order to use this filter, you MUST have AquaTerm.app or some other
 * application capable of handling the AQTProtocol installed
 * on your system.
 *
 * Once connected to the server, all gnuplot primitives are sent, 
 * via the D.O. system, to AquaTerm.app, which produces renders graphs, 
 * manages the windows, takes care of printing etc.
 * 
 *
 * Defaults are
 * n=0
 *
 * to choose window n
 * 'set term aqua <n>"
 *
 */

#include "driver.h"

#ifdef TERM_REGISTER
register_term(aqua)
#endif

#ifdef TERM_PROTO

/* Required entries */
TERM_PUBLIC void AQUA_options __PROTO((void));
TERM_PUBLIC void AQUA_init __PROTO((void));
TERM_PUBLIC void AQUA_reset __PROTO((void));
TERM_PUBLIC void AQUA_text __PROTO((void));
TERM_PUBLIC void AQUA_graphics __PROTO((void));
TERM_PUBLIC void AQUA_move __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void AQUA_vector __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void AQUA_linetype __PROTO((int linetype));
TERM_PUBLIC void AQUA_put_text __PROTO((unsigned int x, unsigned int y,const char *str));
/* Optional entries */
TERM_PUBLIC int AQUA_text_angle __PROTO((int));
TERM_PUBLIC int AQUA_justify_text __PROTO((enum JUSTIFY));
TERM_PUBLIC int AQUA_set_font __PROTO((const char *font));  /* "font,size" */
TERM_PUBLIC void AQUA_set_pointsize __PROTO((double size)); /* notification of set pointsize */
TERM_PUBLIC void AQUA_point __PROTO((unsigned int, unsigned int, int));
TERM_PUBLIC int flags; /* various flags */
TERM_PUBLIC void AQUA_suspend __PROTO((void)); /* after one plot of multiplot */
TERM_PUBLIC void AQUA_resume __PROTO((void));  /* before subsequent plot of multiplot */
TERM_PUBLIC void AQUA_boxfill __PROTO((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height)); /* clear part of multiplot */
TERM_PUBLIC void AQUA_linewidth __PROTO((double linewidth));
TERM_PUBLIC void AQUA_pointsize __PROTO((double pointsize));
#ifdef PM3D
  TERM_PUBLIC int AQUA_make_palette __PROTO((t_sm_palette *palette));
  TERM_PUBLIC void AQUA_set_color __PROTO((double gray));
  TERM_PUBLIC void AQUA_filled_polygon __PROTO((int points, gpiPoint *corners));
#endif /* PM3D */
/* End of entries */

#define AQUA_SCALE_FACTOR 10.0                  /* Increase resolution */ 
#define AQUA_XMAX (11.69*72*AQUA_SCALE_FACTOR)  /* = 842, paper width times screen resolution */
#define AQUA_YMAX (8.26*72*AQUA_SCALE_FACTOR)   /* = 595, paper height times screen resolution */
#define AQUA_VTIC (8*AQUA_SCALE_FACTOR)     
#define AQUA_HTIC (8*AQUA_SCALE_FACTOR)
#define AQUA_VCHAR (16*AQUA_SCALE_FACTOR)       /* default font is Times at 16 points */
#define AQUA_HCHAR (AQUA_VCHAR*6/10)

#define SPECIAL_COLORS 4
#define CYCLIC_COLORS 8
#define PM3D_COLORS (AQUA_COLORMAP_SIZE - CYCLIC_COLORS - SPECIAL_COLORS - 1)

#define GOT_AQUA_PROTO
#endif /* TERM_PROTO */

#ifndef TERM_PROTO_ONLY

#ifdef TERM_BODY
#import "AQTAdapter.h"

#import <Foundation/NSAutoreleasePool.h>
#import <stdarg.h>

/* Debugging extras */
static inline void NOOP_(id x, ...) {;}

#ifdef LOGGING
#define LOG  NSLog
#else
#define LOG  NOOP_
#endif	/* LOGGING */

static NSAutoreleasePool *arpool;   // our autorelease pool 
static id adapter;    // local object manages the D.O. connection
static int currentWindow = 0;		// the only option to set (could be set _before_ instatiation of gnuTermAccess)
static char AQUA_title[MAX_LINE_LEN + 1];
static t_sm_palette *aqua_palette = nil;
//
// ----------------------------------------------------------------
// Gnuplot driver implementation
// ----------------------------------------------------------------
//

enum AQUA_id {
  AQUA_DEFAULT,
  AQUA_TITLE,
  AQUA_OTHER
};


static struct gen_table AQUA_opts[] =
{
  { "d$efault", AQUA_DEFAULT },
  { "ti$tle", AQUA_TITLE },
  { NULL, AQUA_OTHER }
};

//
// AQUA_options is called 0 or more times before a call to AQUA_init occurs.
// It is important that the option <n> is passed correctly to AquaTerm
//
TERM_PUBLIC void
AQUA_options()
{
  struct value a;
  *AQUA_title = 0;
    
  LOG(@"AQUA_options");
  while (!END_OF_COMMAND) 
  {
    switch(lookup_table(&AQUA_opts[0],c_token)) 
    {
     case AQUA_DEFAULT:
      currentWindow = 0;
      c_token++;
      break;
     case AQUA_TITLE:
      c_token++;
      if (!isstring(c_token)) {
          fprintf(stderr, "usage:  set term aqua title \"newtitle\"\n");
      }
      quote_str(AQUA_title, c_token, MAX_LINE_LEN + 1);
            c_token++;

      break;
     case AQUA_OTHER:
      currentWindow = (int) real(const_express(&a));
      break;  
    default:      
      break;
    }
  }
}

TERM_PUBLIC void
AQUA_init()
{
  float fontSize, fontWHRatio;
  LOG(@"Aqua Init");
  if (arpool == NULL)   /* Make sure we don't leak mem by allocating every time */
  {
    arpool = [[NSAutoreleasePool alloc] init]; 
    adapter = [[AQTAdapter alloc] init]; 
  }
  else 
  {
    if (!adapter)	/* server could be invalid (=nil) for several reasons */
    {
      printf("Error -- no adapter!\n");
      exit(1);
    }
  }
  term->xmax = AQUA_XMAX; 
  term->ymax = AQUA_YMAX; 
  term->v_char = (unsigned int) AQUA_VCHAR;
  term->h_char = (unsigned int) AQUA_HCHAR;
  term->v_tic = (unsigned int) AQUA_VTIC;
  term->h_tic = (unsigned int) AQUA_HTIC;  
  //
  // Set up the basic indexed colormap for gnuplot
  //
  //  Special colors
  [adapter setColormapEntry:0 red:0.0 green:0.0 blue:0.0];
  [adapter setColormapEntry:1 red:0.0 green:0.0 blue:0.0];
  [adapter setColormapEntry:2 red:0.0 green:0.0 blue:0.0];
  [adapter setColormapEntry:3 red:0.0 green:0.0 blue:0.0];
  //  Cyclic colors
  [adapter setColormapEntry:4 red:1.0 green:0.0 blue:0.0];
  [adapter setColormapEntry:5 red:0.0 green:1.0 blue:0.0];
  [adapter setColormapEntry:6 red:0.0 green:0.0 blue:1.0];
  [adapter setColormapEntry:7 red:1.0 green:1.0 blue:0.0];
  [adapter setColormapEntry:8 red:1.0 green:0.0 blue:1.0];
  [adapter setColormapEntry:9 red:0.0 green:1.0 blue:1.0];
  [adapter setColormapEntry:10 red:1.0 green:0.5 blue:0.5];
  [adapter setColormapEntry:11 red:0.5 green:1.0 blue:0.5];
}

TERM_PUBLIC void
AQUA_reset()
{
}

TERM_PUBLIC void
AQUA_text()
{
    [adapter closePlot];
}

TERM_PUBLIC void
AQUA_graphics()
{
  NSString *title;
    if(*AQUA_title)
    {
        title = [NSString stringWithCString:AQUA_title];
        *AQUA_title = 0;
    }
    [adapter openPlotIndex:currentWindow size:NSMakeSize(term->xmax/AQUA_SCALE_FACTOR, term->ymax/AQUA_SCALE_FACTOR) title:nil];
}

TERM_PUBLIC void
AQUA_move(unsigned int x, unsigned int y)
{
    [adapter moveToPoint:NSMakePoint(x/AQUA_SCALE_FACTOR, y/AQUA_SCALE_FACTOR)];
}

TERM_PUBLIC void
AQUA_vector(unsigned int x, unsigned int y)
{
  [adapter addLineToPoint:NSMakePoint(x/AQUA_SCALE_FACTOR, y/AQUA_SCALE_FACTOR)];
}

TERM_PUBLIC void
AQUA_linetype(int linetype)
{
  LOG(@"AQUA_linetype(%d)", linetype);
  if (linetype<0)
  {
   NSLog(@"Linetype %d", linetype);
  }
  else
  {
    [adapter takeColorFromColormapEntry:(linetype%CYCLIC_COLORS)+SPECIAL_COLORS];
  }
}

TERM_PUBLIC void
AQUA_put_text(unsigned int x, unsigned int y, const char *str)
{
  if (!strlen(str))
    return;
  [adapter  addLabel:[NSString stringWithCString: str] position:NSMakePoint(x/AQUA_SCALE_FACTOR,y/AQUA_SCALE_FACTOR) angle:0.0 justification:0];
}

TERM_PUBLIC int 
AQUA_justify_text (enum JUSTIFY mode)
{
  // [gnuTermAccess  setJustification:mode];
  return (TRUE);
}

TERM_PUBLIC int
AQUA_text_angle (int angle)
{
  //[gnuTermAccess setTextAngle: angle];
  return (TRUE);
}

TERM_PUBLIC int 
AQUA_set_font(const char *font) /* "font,size" */
{
/*
  float fontWHRatio, fontSize;
  [gnuTermAccess setTextfont:font];
  // FIXME: Does gnuplot process these values?
  fontSize = [[[gnuTermAccess termInfo] objectForKey:@"AQTFontSize"] floatValue];
  fontWHRatio = [[[gnuTermAccess termInfo] objectForKey:@"AQTFontWHRatio"] floatValue];
  term->v_char = (unsigned int) fontSize;
  term->h_char = (unsigned int) (fontWHRatio * fontSize);
*/
  return (TRUE);
}

TERM_PUBLIC void 
AQUA_set_pointsize(double size) /* notification of set pointsize */
{
    LOG(@"AQUA_set_pointsize(%f)", size);
}

TERM_PUBLIC void 
AQUA_point(unsigned int x, unsigned int y, int number)
{
  // Avoid changing lw unless necessary
/*
  if ([gnuTermAccess linewidth] != 1.0)
  {
    double tmplw = [gnuTermAccess linewidth];
    [gnuTermAccess setLinewidth:1.0];
    [gnuTermAccess moveToPoint:NSMakePoint(x/AQUA_SCALE_FACTOR-.5, y/AQUA_SCALE_FACTOR)];
    [gnuTermAccess lineToPoint:NSMakePoint(x/AQUA_SCALE_FACTOR +.5, y/AQUA_SCALE_FACTOR)];
    [gnuTermAccess setLinewidth: tmplw];
  }
  else
  {
    [gnuTermAccess moveToPoint:NSMakePoint(x/AQUA_SCALE_FACTOR-.5, y/AQUA_SCALE_FACTOR)];
    [gnuTermAccess lineToPoint:NSMakePoint(x/AQUA_SCALE_FACTOR +.5, y/AQUA_SCALE_FACTOR)];
  }
*/
  do_point(x, y, number);
}

TERM_PUBLIC void 
AQUA_suspend(void)  /* after one plot of multiplot */
{
  //[gnuTermAccess flushBuffers];
  [adapter render];
}
 
TERM_PUBLIC void 
AQUA_resume(void) /* before subsequent plot of multiplot */
{
}

TERM_PUBLIC void 
AQUA_boxfill(int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height) /* clear part of multiplot */
{
    // FIXME: What does style imply?
    NSRect scaledRect = NSMakeRect(x1/AQUA_SCALE_FACTOR, y1/AQUA_SCALE_FACTOR, width/AQUA_SCALE_FACTOR,     height/AQUA_SCALE_FACTOR);
    [adapter eraseRect:scaledRect];
    [adapter addFilledRect:scaledRect];
}
  
TERM_PUBLIC void 
AQUA_linewidth(double linewidth)
{
  [adapter setLinewidth:linewidth];
}

TERM_PUBLIC void 
AQUA_pointsize(double pointsize)
{
  LOG(@"AQUA_pointsize(%f)", pointsize);
  term_pointsize = pointsize;
}

#ifdef PM3D
  TERM_PUBLIC int 
  AQUA_make_palette(t_sm_palette *palette)
  {
    if (palette == NULL)
    {
        return 128;
    }
    else
    {
        aqua_palette = palette;
    }
  }

  TERM_PUBLIC void 
  AQUA_set_color(double gray)
  {

  /*  [adapter setColorRed:aqua_palette->color[pm3dColor].r 
        green:aqua_palette->color[pm3dColor].g 
        blue:aqua_palette->color[pm3dColor].b];
  */
  }

  TERM_PUBLIC void 
  AQUA_filled_polygon(int points, gpiPoint *corners)
  {
    int i;
    gpiPoint *scaledPoints = (gpiPoint *)malloc(points*sizeof(gpiPoint));
    if (scaledPoints)
      {
	/* Need to rescale the point coordinates */
	for (i=0; i<points; i++)
	  {
	    scaledPoints[i].x = corners[i].x / AQUA_SCALE_FACTOR;
	    scaledPoints[i].y = corners[i].y / AQUA_SCALE_FACTOR;
	  }
	//[gnuTermAccess setPolygonUsing:points corners:scaledPoints];
	free(scaledPoints);
      }
  }
#endif /* PM3D */

#endif /* TERM_BODY */

#ifdef TERM_TABLE

TERM_TABLE_START(aqua_driver)
  "aqua",
  "Interface to graphics terminal server for Mac OS X",
  AQUA_XMAX, AQUA_YMAX, AQUA_VCHAR, AQUA_HCHAR, AQUA_VTIC, AQUA_HTIC, 
  AQUA_options, AQUA_init, AQUA_reset,
  AQUA_text, null_scale, AQUA_graphics, AQUA_move, AQUA_vector,
  AQUA_linetype, AQUA_put_text, 
  /* optionals */
  AQUA_text_angle,
  AQUA_justify_text, AQUA_point, do_arrow, AQUA_set_font,
  AQUA_pointsize, TERM_CAN_MULTIPLOT,
  AQUA_suspend, AQUA_resume,
  AQUA_boxfill, AQUA_linewidth
#ifdef USE_MOUSE
  , 0, 0, 0, 0, 0
#endif /* USE_MOUSE */
#ifdef PM3D
  /*
  , AQUA_make_palette,
  0 // AQUA_previous_palette ,
  AQUA_set_color,
  AQUA_filled_polygon
  */
  ,0,0,0,0
#endif /* PM3D */
TERM_TABLE_END(aqua_driver)

#undef LAST_TERM
#define LAST_TERM aqua_driver

#endif /* TERM_TABLE */
#endif /* TERM_PROTO_ONLY */



#ifdef TERM_HELP
START_HELP(aqua)
"1 aqua",
"?commands set terminal aqua",
"?set terminal aqua",
"?set term aqua",
"?terminal aqua",
"?term aqua",
"?aqua",
"?Aqua",
" Syntax:",
"   set terminal aqua {<n>} {title \"windowtitle\"}",
"",
" where <n> is the number of the window to display the plot in.",
" Default window number is 0, ",
" default windowtitle is \"Figure <n>\"."
END_HELP(aqua)
#endif /* TERM_HELP */


