/* -*- objc -*-
 * $Id: aquaTerm.trm,v 1.28 2004/03/15 12:23:46 persquare Exp $
 *
 */

/* GNUPLOT - aquaTerm.trm */


/*
 * This file is included by ../term.c via ../term.h.
 *
 * This terminal driver supports:
 *     Aqua (Mac OS X/Cocoa)
 *
 * AUTHORS
 *  Per Persson from openstep.trm by Robert Lutwak
 * 
 * Homepage: http://aquaterm.sourceforge.net
 * send your comments or suggestions to (persquare@users.sourceforge.net).
 *
 * This terminal attempts to connect, via the MacOS X Distributed
 * Objects system, to the "aquatermServer."  If there is no such
 * service registered with the OS, the terminal attempts to fire
 * up AquaTerm.app.  If the user has not set the environment variable
 * GNUTERMAPP, the terminal searches for AquaTerm.app in standard 
 * locations like /Applications, ~/Applications, etc.
 * In order to use this filter, you MUST have AquaTerm.app or some other
 * application capable of handling the AQTProtocol installed
 * on your system.
 *
 * Once connected to the server, all gnuplot primitives are sent, 
 * via the D.O. system, to AquaTerm.app, which produces renders graphs, 
 * manages the windows, takes care of printing etc.
 * 
 *
 * Defaults are
 * n=0
 *
 * to choose window n
 * 'set term aqua <n>"
 *
 */

#include "driver.h"

#ifdef TERM_REGISTER
register_term(aqua)
#endif

#ifdef TERM_PROTO

/* Required entries */
TERM_PUBLIC void AQUA_options __PROTO((void));
TERM_PUBLIC void AQUA_init __PROTO((void));
TERM_PUBLIC void AQUA_reset __PROTO((void));
TERM_PUBLIC void AQUA_text __PROTO((void));
TERM_PUBLIC void AQUA_graphics __PROTO((void));
TERM_PUBLIC void AQUA_move __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void AQUA_vector __PROTO((unsigned int x, unsigned int y));
TERM_PUBLIC void AQUA_linetype __PROTO((int linetype));
TERM_PUBLIC void AQUA_put_text __PROTO((unsigned int x, unsigned int y,const char *str));
/* Optional entries */
TERM_PUBLIC int AQUA_text_angle __PROTO((int));
TERM_PUBLIC int AQUA_justify_text __PROTO((enum JUSTIFY));
TERM_PUBLIC int AQUA_set_font __PROTO((const char *font));  /* "font,size" */
TERM_PUBLIC void AQUA_set_pointsize __PROTO((double size)); /* notification of set pointsize */
TERM_PUBLIC void AQUA_point __PROTO((unsigned int, unsigned int, int));
TERM_PUBLIC int flags; /* various flags */
TERM_PUBLIC void AQUA_suspend __PROTO((void)); /* after one plot of multiplot */
TERM_PUBLIC void AQUA_resume __PROTO((void));  /* before subsequent plot of multiplot */
TERM_PUBLIC void AQUA_boxfill __PROTO((int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height)); /* clear part of multiplot */
TERM_PUBLIC void AQUA_linewidth __PROTO((double linewidth));
TERM_PUBLIC void AQUA_pointsize __PROTO((double pointsize));
#ifdef PM3D
  TERM_PUBLIC int AQUA_make_palette __PROTO((t_sm_palette *palette));
  TERM_PUBLIC void AQUA_previous_palette __PROTO((void));
  TERM_PUBLIC void AQUA_set_color __PROTO((double gray));
  TERM_PUBLIC void AQUA_filled_polygon __PROTO((int points, gpiPoint *corners));
#endif /* PM3D */
/* End of entries */

#define AQUA_RESOLUTION (20.0)                  /* Increase resolution */ 
#define AQUA_XMAX (11.75 * 72 * AQUA_RESOLUTION)	/* = paper width (in) times screen resolution */
#define AQUA_YMAX (8.25 * 72 * AQUA_RESOLUTION)	/* = paper height (in) times screen resolution */
#define AQUA_VTIC (8.0*AQUA_RESOLUTION)     
#define AQUA_HTIC (8.0*AQUA_RESOLUTION)
#define AQUA_VCHAR (16.0*AQUA_RESOLUTION)       /* default font is Times at 14 points */
#define AQUA_HCHAR (AQUA_VCHAR*6.0/10.0)

#define SPECIAL_COLORS 4
#define CYCLIC_COLORS 9

#define GOT_AQUA_PROTO
#endif /* TERM_PROTO */

#ifndef TERM_PROTO_ONLY

#ifdef TERM_BODY
#import <aquaterm/AQTAdapter.h>

#import <Foundation/NSAutoreleasePool.h>
#import <Foundation/NSArray.h>
#import <stdarg.h>

#ifdef PM3D
#include "getcolor.h"
#endif


/* Debugging extras */
static inline void NOOP_(id x, ...) {;}

#ifdef LOGGING
#define LOG  NSLog
#else
#define LOG  NOOP_
#endif	/* LOGGING */

/* AquaTerm specific */
static NSAutoreleasePool *arpool;   
static AQTAdapter *adapter;    

/* Internal state */
static int AQUA_plotRef = 0;		/* A ref to the current plot */
static char AQUA_title[MAX_LINE_LEN + 1] = "Figure 0"; /* Plot title (in windowbar) */

static unsigned int AQUA_xSize = AQUA_XMAX; /* plot horizontal size */
static unsigned int AQUA_ySize = AQUA_YMAX; /* plot vertical size*/

static int AQUA_LineType = -3;	/* current line type*/
static float AQUA_LineWidth = 1.0; /* current line width*/
static float AQUA_TextAngle = 0.0;	/* current text orientation*/
static enum JUSTIFY AQUA_TextJust = LEFT; /* current text justification*/

/* default text font family: */
static char AQUA_fontNameDef[MAX_ID_LEN + 1] = "Times-Roman"; 
static double AQUA_fontSizeDef = 14;	/* default text size*/
/* current text font family: */
static char AQUA_fontNameCur[MAX_ID_LEN + 1] = "Times-Roman";
static double AQUA_fontSizeCur = 14;	/* current text size*/

/* Helper functions */
static void AQUA_local_reset __PROTO(());

/*
// ----------------------------------------------------------------
// Gnuplot driver implementation
// ----------------------------------------------------------------
//
//   Current options are:
//   <n> title "theTitle" size <x> <y> fname "fontface" fsize <fontsize>   
*/
TERM_PUBLIC void
AQUA_options()
{
  struct value a;
	AQUA_local_reset();
    if (!END_OF_COMMAND  && !isstring (c_token)) {	/* plot ref number*/
		AQUA_plotRef = (int) real (const_express (&a));
    }

    if (!END_OF_COMMAND) {	/* plot title*/
	if (almost_equals (c_token, "ti$tle"))  {
	    c_token++;

	    if (!END_OF_COMMAND && isstring (c_token)) {
		quote_str (AQUA_title, c_token, MAX_LINE_LEN);
		c_token++;
	    } else
		int_error(c_token,"fname: expecting plot title");
	}
    }
    
	if (AQUA_title[0]=='\0') /* always set title */
		sprintf(AQUA_title, "Figure %d", AQUA_plotRef);

    if (!END_OF_COMMAND) {	/* get terminal size*/
	if (almost_equals (c_token, "s$ize")) {
	    double value;

	    c_token++;

	    if (END_OF_COMMAND)
		int_error(c_token,"expecting x size");
	    value = real(const_express (&a));
	    if (value < 2 || value > 2048)
		int_error(c_token,"x size out of range");
	    AQUA_xSize = (unsigned int) value * AQUA_RESOLUTION;

	    if (END_OF_COMMAND)
		int_error(c_token,"expecting y size");
	    value = real(const_express (&a));
	    if (value < 2 || value > 2048)
		int_error(c_token,"y size out of range");
	    AQUA_ySize = (unsigned int) value * AQUA_RESOLUTION;

	    }
    }

    if (!END_OF_COMMAND) {	/* get default font family name*/
	if (almost_equals (c_token, "fn$ame"))  {
	    c_token++;

	    if (!END_OF_COMMAND && isstring (c_token)) {
	      quote_str (AQUA_fontNameCur, c_token, MAX_ID_LEN);
	      c_token++;
	    } else
	      int_error(c_token,"fname: expecting font name");
	}
    }

    if (!END_OF_COMMAND) {	/* get default font size*/
      if (almost_equals (c_token, "fs$ize")) {
	c_token++;

	if (END_OF_COMMAND)
	  int_error(c_token,"fsize: expecting font size");
	AQUA_fontSizeCur = real (const_express (&a));
      }
    }

    if (!END_OF_COMMAND)
      int_error(c_token, "unexpected text at end of command"); 

    /* Save options back into options string in normalized format */
    sprintf(term_options, "%d title '%s' size %d %d fname '%s'  fsize %g",
	    AQUA_plotRef,
	    AQUA_title,
	    (unsigned int) (AQUA_xSize/AQUA_RESOLUTION), (unsigned int) (AQUA_ySize/AQUA_RESOLUTION),
	    AQUA_fontNameCur, AQUA_fontSizeCur);
}

static void
AQUA_local_reset()
{
  AQUA_title[0]	= '\0';
  AQUA_xSize      = AQUA_XMAX;
  AQUA_ySize      = AQUA_YMAX;
  strcpy(AQUA_fontNameCur, AQUA_fontNameDef);
  AQUA_fontSizeCur  = AQUA_fontSizeDef;
}


TERM_PUBLIC void
AQUA_init()
{
  float fontSize, fontWHRatio;
  NSString *title;
  LOG(@"Aqua Init (open plot)");
  if (arpool == NULL) {
    /* FIXME: This should be removed when pools are handled in gnuplot proper */
    arpool = [[NSAutoreleasePool alloc] init];
  }
  if (adapter == NULL) {
    adapter = [[AQTAdapter alloc] init]; 
    if (!adapter) { /* server could be invalid (=nil) for several reasons */
      printf("Error -- no adapter!\n");
      exit(1);
    }
  }

  /* Must open plot before all other commands */
  [adapter openPlotWithIndex:AQUA_plotRef];

  /* set xmax, ymax*/
  term->xmax = AQUA_xSize;
  term->ymax = AQUA_ySize;
  /* set current font*/
  [adapter setFontname:[NSString stringWithCString:AQUA_fontNameCur]];
  [adapter setFontsize:AQUA_fontSizeCur];                                                                   
  /* set h_char, v_char*/
  term->h_char = (int) (AQUA_fontSizeCur * 0.7 * AQUA_RESOLUTION);
  term->v_char = (int) (AQUA_fontSizeCur * 1.5 * AQUA_RESOLUTION);
  /* set h_tic, v_tic*/
  term->h_tic = term->v_char / 2;
  term->v_tic = term->v_char / 2;

  [adapter setPlotSize:NSMakeSize(AQUA_xSize/AQUA_RESOLUTION, AQUA_ySize/AQUA_RESOLUTION)];
  [adapter setPlotTitle:[NSString stringWithCString:AQUA_title]];
  
  //
  // Set up the basic indexed colormap for gnuplot
  //
  //  Special colors
  [adapter setColormapEntry:0 red:0.1 green:0.1 blue:0.1]; // linetype -4
  [adapter setColormapEntry:1 red:0.9 green:0.9 blue:0.9]; // linetype -3 (xor;interactive) light gray
  [adapter setColormapEntry:2 red:0.0 green:0.0 blue:0.0]; // linetype -2 (border) black
  [adapter setColormapEntry:3 red:0.8 green:0.8 blue:0.8]; // linetype -1 (gridlines) light grey
  //  Cyclic colors
  [adapter setColormapEntry:4 red:1.0 green:0.0 blue:0.0]; // red
  [adapter setColormapEntry:5 red:0.0 green:1.0 blue:0.0]; // green	
  [adapter setColormapEntry:6 red:0.0 green:0.0 blue:1.0]; // blue
  [adapter setColormapEntry:7 red:1.0 green:0.0 blue:1.0]; // magenta
  [adapter setColormapEntry:8 red:0.0 green:1.0 blue:1.0]; // cyan
  [adapter setColormapEntry:9 red:0.6275 green:0.3216 blue:0.1765]; // sienna
  [adapter setColormapEntry:10 red:1.0 green:0.6471 blue:0.0];// orange
  [adapter setColormapEntry:11 red:0.5 green:0.4980 blue:0.3137];// coral
  [adapter setColormapEntry:12 red:0.25 green:0.25 blue:0.25];// grey

}

TERM_PUBLIC void
AQUA_reset()
{
  LOG(@"Aqua reset");
}

TERM_PUBLIC void
AQUA_text()
{
  LOG(@"Aqua text (render)");
  [adapter renderPlot];
}

TERM_PUBLIC void
AQUA_graphics()
{
  LOG(@"Aqua graphics (empty, should erase?)");
  [adapter eraseRect:NSMakeRect(0.0, 0.0, AQUA_xSize/AQUA_RESOLUTION, AQUA_ySize/AQUA_RESOLUTION)];
}

TERM_PUBLIC void
AQUA_move(unsigned int x, unsigned int y)
{
  [adapter moveToPoint:NSMakePoint(x/AQUA_RESOLUTION, y/AQUA_RESOLUTION)];
}

TERM_PUBLIC void
AQUA_vector(unsigned int x, unsigned int y)
{
  [adapter addLineToPoint:NSMakePoint(x/AQUA_RESOLUTION, y/AQUA_RESOLUTION)];
}

TERM_PUBLIC void
AQUA_linetype(int linetype)
{
  LOG(@"AQUA_linetype(%d) ---> entry: %d", linetype, (linetype%CYCLIC_COLORS)+SPECIAL_COLORS);
  /* Note: this operation maps linestyle -4 to -1 onto colormap entries 0 to 3 */
  if (linetype != AQUA_LineType)
    {
      AQUA_LineType = linetype;
      [adapter takeColorFromColormapEntry:(linetype%CYCLIC_COLORS)+SPECIAL_COLORS];
    }
}

TERM_PUBLIC void
AQUA_put_text(unsigned int x, unsigned int y, const char *str)
{
  LOG(@"put:%s",str);
  if (!strlen(str))
    return;
  [adapter  addLabel:[NSString stringWithCString: str] 
	    atPoint:NSMakePoint(x/AQUA_RESOLUTION, y/AQUA_RESOLUTION) 
	    angle:AQUA_TextAngle 
	    align:(AQUA_TextJust | AQTAlignMiddle)];
}

TERM_PUBLIC int 
AQUA_justify_text (enum JUSTIFY mode)
{
  AQUA_TextJust = mode;
  return (TRUE);
}

TERM_PUBLIC int
AQUA_text_angle (int angle)
{
  LOG(@"Angle %d", angle);
  AQUA_TextAngle = (float)angle;
  return (TRUE);
}

TERM_PUBLIC int 
AQUA_set_font(const char *font) /* "font,size" */
{
  NSString *fontFace = [NSString stringWithCString:AQUA_fontNameCur];
  float fontSize = AQUA_fontSizeCur;
  if (strlen(font)>0)
    {
      NSArray *parts = [[NSString stringWithCString:font] componentsSeparatedByString:@","];            
      if ([parts count] < 2)
	{
	  NSLog(@"Error: %@", [NSString stringWithCString:font]);                                    
	}
      else
	{
	  fontSize = [[parts objectAtIndex:1] floatValue];                                           
	  fontFace = [parts objectAtIndex:0];                                                        
	}
    }
  
  LOG(@"Setting:(%@,%f)", fontFace, fontSize);                                                    
  [adapter setFontname:fontFace];
  [adapter setFontsize:fontSize];                                                                   

  term->h_char = (int) (fontSize * 0.7 * AQUA_RESOLUTION);
  term->v_char = (int) (fontSize * 1.5 * AQUA_RESOLUTION);
  
  return (TRUE);
}

TERM_PUBLIC void 
AQUA_set_pointsize(double size) /* notification of set pointsize */
{
  LOG(@"AQUA_set_pointsize(%f)", size);
}

TERM_PUBLIC void 
AQUA_point(unsigned int x, unsigned int y, int number)
{
  // The default dot-routine doesn't work with AQT
  if (number<0)
    {
      [adapter setLinewidth:1.0];
      [adapter moveToPoint:NSMakePoint(x/AQUA_RESOLUTION, y/AQUA_RESOLUTION)];
      [adapter addLineToPoint:NSMakePoint(x/AQUA_RESOLUTION+1.0, y/AQUA_RESOLUTION)];
      return;
    }
  do_point(x, y, number);
}

TERM_PUBLIC void 
AQUA_suspend(void)  /* after one plot of multiplot */
{
  [adapter renderPlot];
}
 
TERM_PUBLIC void 
AQUA_resume(void) /* before subsequent plot of multiplot */
{
}

TERM_PUBLIC void 
AQUA_boxfill(int style, unsigned int x1, unsigned int y1, unsigned int width, unsigned int height) /* clear part of multiplot */
{
  float r,g,b;

  LOG(@"\nstyle=%d\nstyle & 0xf = %d\nfillpar=%d\n", style, style & 0xf, style >> 4);
  
  // Save current color
  [adapter getColorRed:&r green:&g blue:&b];

#if USE_ULIG_FILLEDBOXES
  /* fillpar:
   * - solid   : 0 - 100
   * - pattern : 0 - 100
   */
  int fillpar = style >> 4;
  
  style &= 0xf;
  
  switch (style) 
    {
    case 0: /* fill with background color */
      {
	float rb, gb, bb;
	[adapter getBackgroundColorRed:&rb green:&gb blue:&bb];
	[adapter setColorRed:rb green:gb blue:bb];  
      }
      break;
    case FS_SOLID: /* solid fill */
      {
	// Alpha channel?
	float density = (float)fillpar*0.01;
	[adapter setColorRed:r green:g*density blue:b*density];
      }
      break;
    case FS_PATTERN: /* pattern fill */
      // Colors?
      [adapter takeColorFromColormapEntry:(fillpar%CYCLIC_COLORS)+SPECIAL_COLORS];
      break;
    default:
      break;
    }
#else
  // FIXME: Actions here???
#endif
  NSRect scaledRect = NSMakeRect(x1/AQUA_RESOLUTION, y1/AQUA_RESOLUTION, width/AQUA_RESOLUTION, height/AQUA_RESOLUTION);
  [adapter eraseRect:scaledRect];  
  [adapter addFilledRect:scaledRect];
  // Restore color
  [adapter setColorRed:r green:g blue:b];
}
  
TERM_PUBLIC void 
AQUA_linewidth(double linewidth)
{
  [adapter setLinewidth:linewidth];
}

TERM_PUBLIC void 
AQUA_pointsize(double pointsize)
{
  LOG(@"AQUA_pointsize(%f)", pointsize);
  term_pointsize = pointsize;
}

#ifdef PM3D
TERM_PUBLIC int 
AQUA_make_palette(t_sm_palette *palette)
{
  if (palette == NULL) {
    /* AquaTerm can do continuous colors */
    return 0;
  }
  return 0;
}

TERM_PUBLIC void 
AQUA_set_color(double gray)
{
    rgb_color color;
    
    if( sm_palette.use_maxcolors != 0 ) {
      /* finite nb of colors explicitly requested */
      if( gray >= ( (double)(sm_palette.use_maxcolors-1) )
	  / sm_palette.use_maxcolors )
	gray = 1.0;
      else
	gray = floor( gray * sm_palette.use_maxcolors ) 
	  / sm_palette.use_maxcolors;
    }
    
    rgb1_from_gray( gray, &color );
    [adapter setColorRed:color.r green:color.g blue:color.b];
    AQUA_LineType = LT_UNDEFINED; 
}

TERM_PUBLIC void 
AQUA_filled_polygon(int pc, gpiPoint *corners)
{
  int i;
  [adapter moveToVertexPoint:NSMakePoint(corners[0].x/AQUA_RESOLUTION,
					 corners[0].y/AQUA_RESOLUTION)];
  for (i=1; i<pc; i++) 
    {
      [adapter addEdgeToVertexPoint:NSMakePoint(corners[i].x/AQUA_RESOLUTION,
						corners[i].y/AQUA_RESOLUTION)];	
    }
}

TERM_PUBLIC void
AQUA_previous_palette(void)
{
}

#endif /* PM3D */

#endif /* TERM_BODY */

#ifdef TERM_TABLE

TERM_TABLE_START(aqua_driver)
  "aqua",
  "Interface to graphics terminal server for Mac OS X",
  0 /* xmax */ , 0 /* ymax */ , 0 /* vchar */ , 0 /* hchar */ ,
  0 /* vtic */ , 0 /* htic */ ,
  AQUA_options, AQUA_init, AQUA_reset,
  AQUA_text, null_scale, AQUA_graphics, AQUA_move, AQUA_vector,
  AQUA_linetype, AQUA_put_text, 
  /* optionals */
  AQUA_text_angle,
  AQUA_justify_text, AQUA_point, do_arrow, AQUA_set_font,
  AQUA_pointsize, TERM_CAN_MULTIPLOT,
  AQUA_suspend, AQUA_resume,
  AQUA_boxfill, AQUA_linewidth
#ifdef USE_MOUSE
  , 0, 0, 0, 0, 0
#endif /* USE_MOUSE */
#ifdef PM3D
  , AQUA_make_palette,
  AQUA_previous_palette, 
  AQUA_set_color,
  AQUA_filled_polygon
#endif /* PM3D */
TERM_TABLE_END(aqua_driver)

#undef LAST_TERM
#define LAST_TERM aqua_driver

#endif /* TERM_TABLE */
#endif /* TERM_PROTO_ONLY */



#ifdef TERM_HELP
START_HELP(aqua)
"1 aqua",
"?commands set terminal aqua",
"?set terminal aqua",
"?set term aqua",
"?terminal aqua",
"?term aqua",
"?aqua",
"?Aqua",
" Syntax:", 
"   set terminal aqua {<n>} {title \"windowtitle\"} {size <x> <y>} {fname \"fontface\"} {fsize <fontsize>}",
"",
" where <n> is the number of the window to display the plot in.",
" Default window number is 0, ",
" default window title is \"Figure <n>\",",
" default size is 846x594 pt (11.75x8.25 in),",
" default font is \"Times-Roman\",",
" default fontsize is 14.0 pt."
END_HELP(aqua)
#endif /* TERM_HELP */


